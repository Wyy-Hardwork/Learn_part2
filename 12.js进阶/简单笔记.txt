1.局部作用域
-函数作用域/块作用域
函数内部声明的变量只能在函数内部访问
函数执行完毕后，函数内部的变量会被清空（垃圾回收）

-块作用域(let,const拥有)
标志就是 { }，子括号可以用父，父不可以用子。

2.作用域链
当前作用域查找不到，会逐级查找父级作用域直至全局作用域

3.垃圾回收机制
-内存的生命周期
内存分配：当我们声明变量、函数、对象时候，系统会自动为其分配内存
内存使用：读写内存，也就是使用变量、函数等
内存回收：使用完毕，由垃圾回收器自动回收不再使用的内存
--全局变量一般不会回收（关闭页面回收）
局部变量的值，不用了，就会自动回收
--内存泄漏
程序中分配的内存由于某种原因未释放或者无法释放，叫做内存释放↓

-js垃圾回收机制-算法说明
（一个复杂数据赋给另一个值，给的就是这个复杂数据的堆内存地址，也就是浅拷贝）
（如果直接操作复杂数据类型，如数组的某个索引，那就是在堆中操作，导致了一起变化）
栈：由操作系统自动分配，自动释放函数的参数值、局部变量等，基本数据存放在栈
堆：由程序员分配释放，若程序员不释放，就由“垃圾回收机制”回收。复杂数据存放在堆
--引用计数算法
IE采用，引用一次+1，减少一个引用-1，次数0释放内存，比如把arr = null一下，无指针指向，释放。
但是堆内操作会相互引用的话，导致计数不减，内存泄露
--标记清除算法
从根部（全局对象位置），只要是能从根部抵达都算要使用(全局变量就只会在关闭浏览器释放)。
无法从根部触及到的复杂数据被标记为不再使用，稍后进行回收。
(从全局变量出发,无法抵达就会被清除,闭包里面有可能变量会被全局变量指,从而未回收导致内存问题(内存泄漏))

-闭包（Clousure）
用在一个函数里面有个参数，还有个和参数同级或者子级的函数（反正值会作为参数传进内部函数），
然后这个内部函数会带着这个参数一起被return出去（return fn保持函数，而非调用），
（内层函数和外层变量一起形成闭包）
--那么我们想在一个函数内部也有限权访问另一个函数内部的变量该怎么办呢？这就是闭包的意义
（封闭数据，让外部也可以访问内部的变量）
--官方一点的说法:闭包=内层函数+外层函数变量;
封闭数据,实现数据私有,外部也可以访问内部的变量;
可能会引起内存泄露.

-闭包引出的for循环代码块(自理解)
for循环简单地看成重复代码,拥有代码块(让let有效),每次会改变for里参数的值,然后再执行代码块里的代码;
如果for循环用的是var,就会出现变量污染问题,尤其是for循环里直接用setTimeout尤为明显;
但是可以用函数包裹setTimeout,然后再自调用,就可以得到类似let块级作用域的作用

4.变量提升
-Js的缺陷,允许变量被声明之前访问(仅限var),不过没被赋值之前还是undefined,不像let会直接报错.
进入某个作用域,js会把当前作用域的var提升到"当前"作用域的最前面,只提升声明,不提升赋值
--注意函数在全局调用,var依然只会提升到函数的最前面,而不是全局作用域.

5.函数提升
-函数可以在声明前调用，效果同var，也是当前作用域（fun() 可以直接在声明前function fun()使用）
-函数表达式 var fun = functoin()不存在提升现象，直接fun()在前面会报错

6.函数的动态参数，剩余参数
-不写参数，写arguments，是个伪数组
-arguments只存在于函数中
--直接在参数里写...arr可以动态接收参数，arr是一个数组
funtion a(...arr)或者function a(a,b,...arr)所以我叫剩余参数
区别在于一个是伪数组，一个是真数组，建议使用剩余参数
网上结论拓展运算符和剩余参数刚好相反，一个拆一个合

7.箭头函数
箭头函数不能使用arguments参数，但可以用剩余参数
都知道，但是return的是个数组
let a = () => {return {a:1}}
简写为 let a = () => ({a:1})
--this指向和父级一样，上一级作用域

8.环境对象this
this 关键字指的是当前执行上下文的对象
谁调用this就指向谁，在最外层直接调用函数就是window

9.回调函数
函数A作为参数传递给函数B，A就是回调函数

10.解构
--在右边解构，在左边剩余参数
-解构是将数组、对象的单元值快速批量赋值给一系列变量的简洁语法
记得解构时候数组写上[]，对象写上{}
交换值也很方便。
还要注意数组开头vscode不认识，记得加一个;
多维数组也能解构
-解构对象要求变量名和属性名一致

11.构造函数
-为了创造多个类似对象
function结合this，现在知道this指向了，哈哈
function Person(name) = {this.name = name}，这this明显指向a
-构造函数命名要以大写字母开头
-需要new操作符来执行,使用new关键字调用函数的行为叫做实例化
-实例化构造函数时没有参数可以省略
-构造函数内部没有return，返回值就是新建的对象（return）
-new Object()和new Date()也是实例化构造函数
--函数调用时不会创建对象的，但是如果new，会立即创建一个新的空对象；
然后this指向这个对象，执行构造函数代码，通过this添加新属性；
返回该对象
--实例成员和静态成员（实例成员是已经实例化，加对象加函数不影响其他的。静态成员在构造函数，改了就影响其他的）

12.内置构造函数
Object，Array，String，Number
-平时使用的是字面量方式声明对象，而非构造函数
-Object的三种常用静态方法（没有Prototype），记住静态方法不具备继承性，因为没在prototype上
Object.keys 获取对象所有的属性（键），返回的是一个数组
Object.values 获取对象所有的值（value），返回的是一个数组
Object.assign(空对象，被拷贝) 拷贝对象;可以只写一个参数，但原本对象会被改变。可以在尾巴后面多谢键值，用作插入

-Array
以下都会遍历数组
forEach不返回，filter返回符合要求的item，map比forEach多返回和可中断，
reduce返回累计处理的结果(俩参数，前后以及初始值，有return，每次循环把上一次返回值作为prev)
-every,some, 回调函数，一个&& 一个||，返回boolean
-find((item)=>{return item <3}) return第一个符合要求的item，如果是对象的话会return对象，挺好。

-String
string.split('-') 把字符串根据-分割成数组与join()相反
string.substring(3[,9]) 截取字符串，按索引 
string.starWith('x',3) 判断字符以某个开头,第二个参数索引开始，boolean
string.includes('x',3) 包含,第二个参数索引开始，boolean

-Number
num.toFixed()精度，参数保留几位

13.原型
结合构造函数看了下，怪不得js万物皆对象
-构造函数特性，每次new都会开辟一个新的堆，如果有很多需要复用的地方，就会显得浪费内存，就需要原型了
如果你需要共享某个函数或参数，请使用prototype吧.尽可能用prototype来构建函数，节约内存
****不光是this，其原型prototype也同样指向调用者****
***正是因为原型的this也指向调用者，所以获取调用者的参数变得可行***
***constructor可以用于指回函数，防止prototype不是增加而是等于之后把constructor替换掉的问题，
用于指明原型属于谁，相当于标记作用吧 constructor:Array
Array.prototype.constructor === Array 返回true***
**相较于prototype，是只读的,对象原型 __proto__也叫[[prototype]]，存在于实例对象，指向这个实例的原型对象如Array.prototype === __proto__ true，
对象原型也有个constructor，和原型对象里面的===true **
-例子-
*arr.__proto__ === Fun.prototype | true*
*arr.__proto__.constructor === Fun | true*
*Fun === Fun.prototype.constructor | true*

-构造函数可以通过prototype来继承其他的构造函数(Woman.prototype = new Person())，实现差异化
这行为不会替换其他原型方法，而是增加。我想new本来就是增加吧，只不过实例对象是在空的地方增加
实现继承：子类.prototype = new 父类()
prototype用于定义,__proto__用于指向创造了我的构造函数的prototype
prototype包含着constructor在内的一系列原型参数以及方法
--每个对象有个--proto--,每个函数有个prototype
--每个prototype对象有个constructor指向自己的构造函数Fun.prototype.constructor

14.原型链
基于原型对象的继承，使得不同构造函数的原型对象关联在一起，并且这种关联
是一种链状结构。把这种原型对象的链状关系称为原型链

-当访问一个对象的属性(包括方法)时，首先查找自身有没有该属性
没有就查找它的实例对象原型__proto__，这个等价于自己构造函数的prototype原型
再没有就继续向上找Object的prototype原型，相当于又加了个__proto__查找
直到找到null为止(再加一个__proto__)
可以用instanceof可以查父查爷，总之查归属，返回true和false |object instanceof Object

15.深浅拷贝
-直接复制是连地址都复制了，连浅拷贝都算不上
-深浅拷贝只针对引用类型(Array,Object),
-浅拷贝给你一个新内存地址，可以复制基本数据类型(没内存地址)。
---*基本数据类型无论怎样都是深拷贝*---，不如结论说深拷贝是拷贝值而非地址
不过只能复制一层，如果有第二层复制的还是一个内存地址

---深拷贝
原生js要用到递归和for循环遍历，总之不能把内存地址赋值给对象
lodash插件cloneDeep()函数
const o = JSON.parse(JSON.stringify(obj))

16.抛出异常
throw会中止程序，配合new Error('')使用
try尝试执行代码，错误执行catch代码块，不中断程序执行；不过err.message写死
debugger会暂停代码，断点，直接跳过去(资源里Source)

17.处理this
-fn.call(obj,1,2)改变fn函数的this指向,并且执行fn;1,2是传给fn(x,y)的参数
-fn.apply(obj,[1,2])也是传给fn(x,y)，不过apply写数组
-fn.bind()，bind不会立马调用，但也可以改变this指向；写法同call

18.防抖节流
setTimeout里面不能写clearTimeout，要写null来清除
推荐使用lodash库




