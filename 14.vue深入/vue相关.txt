1.生命周期，每个开始，在下一个----，就代表已经完成
--------------------------------------------
1.1.开始new Vue()创建实例
1.2.开始初始化当前实例的所有生命周期函数
-----------------beforeCreate---------------
1.3.开始初始化实例上的data和methods，watch，computed
-----------------created--------------------(完成，现在可以获取data和methods的值了)
1.4.判断一下，好像跟我没啥关系(Has 'el' option?)
1.5.把template指定的模板字符串，编译成render函数(渲染函数)
1.6.在渲染函数形成之后，生成虚拟DOM
-----------------beforeMount--------------------
1.7.开始把内存中渲染好的HTML结构覆盖到页面上，覆盖el指定的区域
-----------------mounted------------------------(页面已经显示完毕，流程结束)

-***当data数据改变时，触发新钩子，还有下文->***
---beforeUpdate---(此时data数据已经是最新，但用户看的还是老数据)
1.8.diff算法对虚拟DOM进行修改，针对性修改DOM树，执行页面更新
---beforeUpdate---(此时页面已经完成了更新，data和页面都是最新的)

-***当vm实例即将销毁时，触发新钩子***
---beforeDestroy---(此时vm即将被销毁，一切正常)
1.9.正在销毁vm实例对象
---destroyed---(此时vm实例已经销毁，无法正常工作)


2.关于数据挂载问题(不同生命周期发请求)
-beforeCreate因为还没有解析虚拟DOM，这个时候发请求可以达到最高性能；
不过缺点就是白屏时间太久了，一般用于整页加载完毕，用一个loading页面比较好。
-mounted优先显示出页面框架然后再加载数据，但这样会导致虚拟DOM更新(data变化)
进而导致真实DOM更新，性能会低一点。
-但是mounted有$nextTick()的优化方式，当数据发生变化时，Vue会异步更新DOM，
避免不必要的DOM更新。

3.async await补充
await必须在async中才行，作用类似then，会把下一行起代码放入微任务队列，
就像放进了then一样，也就是then语法糖了，省的写太长。

4.组件间传值
--父子--
1.子通过props接收父组件的数组，子组件通过emit触发事件
2.ref属性给子组件设置一个名字，父组件通过$refs组件获取子组件，子组件通过$parent获取父组件
--兄弟，任意组件--
eventBus方法
--vuex和pinia--

5.computed
可以用来配合watch进行组件间传值，不过computed是只读的。

6.vue常用修饰符
.prevent提交时间不会重载页面
.stop阻止单击事件冒泡
.self事件触发在自身，而不是子元素时候触发

7.vue的diff算法
1.数据改变后触发setter
2.setter触发Dep.notify通知订阅者
3.patch(oldNode,newNode)对比新旧两个节点
4.标签(div、span)不同直接替换，同类进一步执行patchVnode(oldNode,newNode)方法
--4.对比顺序如下--
在Vue的diff算法中，对比的优先顺序如下：
1.节点类型：如果新旧节点的节点类型不同，那么直接替换整个节点。这是因为节点类型不同意味着节点的结构、属性、子节点等都不同，无法通过更新的方式来改变节点。
2.(v-for)节点key：如果新旧节点的key不同，那么直接替换整个节点。这是因为key是用来标识节点的唯一性的，如果key不同，那么新旧节点无法对应上，需要替换整个节点。
3.属性：如果新旧节点的属性不同，那么更新节点的属性。
4.子节点：如果新旧节点的子节点不同，那么递归地对子节点进行比较和更新。
5.文本内容：如果新旧节点的文本内容不同，那么更新节点的文本内容。
这个优先顺序的原则是尽量减少DOM操作，先比较能够直接决定节点是否需要更新的属性，再逐渐向下比较。如果在比较的过程中发现节点需要更新，就尽可能地通过更新原节点来减少DOM操作。
---
5.1.更新只会进行*同级比对*，减少时间复杂度，并且采用了*首尾指针算法*；
首尾指针算法是把开头设置start，末尾设置end，用旧的节点去对比新的节点，如果不同，
继续对比下一个新节点；如果相同，旧真实DOM的节点位置会移动到和新虚拟DOM一致的位置；
一旦比对成功，是start节点就向右移动，是end节点就向左移动(新旧都是)；
直到旧start节点超过旧end节点位置，对比终止。此时如果有新东西，刚好可以直接插入空位；如果虚拟DOM少了，直接删除就行，很神奇！
https://www.bilibili.com/video/BV1JR4y1R7Ln/?spm_id_from=333.337.search-card.all.click&vd_source=166c3469b26f6999609e6c80a06d20ed
*如果在v-for中更新标签，则会利用key来对比节点，早发现早防止递归，可以大幅优化*

8.vue的导航守卫
1.全局前置守卫
router.beforeEach((to,from)=>{})
-底层用Promise实现，等待所有全局守卫状态都为resolve时候，路由跳转才会在
then这个微任务中执行。
全局前置守卫是个异步任务，除了自己阻塞then的路由跳转，其他任务可以一起处理
2.

9.v-for和v-if不要用在一个标签上
因为v-for的优先级要高于v-if，每个if都会判断一次，有性能问题；
最好将v-for放在循环嵌套外
如果if在循环内部，可以考虑用computed将数组内参数通过filter处理布尔值

10.data实例时候,可以是函数,也可以是对象
const app = new Vue({ el: "#app",data:{foo:'foo'}})
但是组件中定义data属性,只能是一个函数;定义对象则会报错.
-可是为什么组件data需要定义成函数呢?
组件是通过构造函数构建的,其data存在于构造原型上的data:
function Component(){
}
Component.prototype.data = {
	count : 0
}
之后再new显然改变的都是一个值了;但是
function Component(){
	this.data = this.data()
}
Component.prototype.data = function (){
    return {
   		count : 0
    }
}
各自的data()都是被自身调用,this地址也就自然指向调用者了
-根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况
-组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，
产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象

11.Vue组件间通信
父子组件:
父传子
(1)子组件设置props属性,接收父组件传递的参数<Children name="jack" age=18 />  
(2)父组件使用子组件标签通过字面量传递值props: ['name','address','age']

$emit触发自定义事件:
子传父
(1)子组件通过$emit自定义事件,第二个参数为传递的数值 this.$emit('add',goods)
(2)父组件绑定监听器获取子组件传递的参数

(1)父组件使用子组件时候设置ref <Children ref="foo" />  
(2)父组件通过设置子组件ref获取数据 this.$refs.foo

兄弟组件传值
EventBus中央事件总线,$emit出发时间传值,$on监听自定义事件

vuex,pinia

12.双向绑定
把Model和View模块绑定,js更新View更新,View更新Model也更新.
这里需要了解ViewModel:
数据变化后更新视图,视图变化后更新数据